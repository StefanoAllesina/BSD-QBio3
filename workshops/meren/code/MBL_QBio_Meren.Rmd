---
output: 
  pdf_document: 
    highlight: tango
---

# Oral microbiome

Instructor: **A. Meren Urat**
Course Assistant: **Alon Shaiber**

### Introduction

The purpose of this document is to walk you through an analysis of microbiome data coming from samples collected from the oral cavity of 148 healthy individuals.

The main question is: do microbes live in your tongue more similar to the ones that live on your cheek, or more similar to the ones that live on the tongue of the person next to you.

Understanding how microbes partition a given environment is a central question. Why not all microbes live everywhere?

### Setting the stage

The primary raw from microbial communities was first generated by the Human Microbiome Project (HMP, https://hmpdacc.org/), a National Institutes of Health initiative to make sense of the 'normal microbiome' of healthy individuals. The HMP sampled many volunteers and many body sites. Including samples collected from the gut, urogenitary tract, nasal and oral cavities, and skin. We focused on the oral cavity to characterize the microbial communities in this particular environment in a highly resolved manner using 'oligotypes' in our 2014 paper (http://www.pnas.org/content/111/28/E2875.short). The data essentially come from the supplementary tables of this study.

Let's first load the libraries we are going to be using:

```{r}
suppressPackageStartupMessages(library(vegan))
suppressPackageStartupMessages(library(reshape2))
suppressPackageStartupMessages(library(ggplot2))
```

If you are missing any of these libraries you can install them using `install.packages("LIBRARY_NAME_HERE")` notation.

There are two data files for you to read in. The first one is the observation matrix that shows the distribution of each oligotype across each sample:

```{r}
oligotypes <- as.data.frame(read.table('../data/oligotypes.txt',
                            header = TRUE,
                            sep="\t"))
```

The second data file contains data about our samples:

```{r}
samples <- as.data.frame(read.table('../data/samples.txt',
                                    header = TRUE,
                                    sep="\t"))
```

Feel free to take a look at its format:

```{r}
head(samples)
```

Samples in our data describes the following two main environments:

```{r}
levels(samples$environment)
```

These ten more specific body sites:

```{r}
levels(samples$site)
```

While we have 148 individuals:

```{r}
length(levels(samples$individual))
```

We have a total of 1475 samples:

```{r}
length(levels(samples$sample))
```

Fine. We have everything we need.


### A visualization-driven exploration of the data

Introduction to MDS here:

We can take a very quick look at the data:

```{r}
# generate the mds object using the Morisita-Horn distance
# (this will take some time)
mds <- metaMDS(oligotypes[,-1], distance='horn')

# show it
plot(mds)
```

We an all agree that this looks quite useless. We could use `ggplot` to manipulate it and add more information into it in an intuitive manner, but `ggplot` will not like how the `mds` object is formatted. We better turn it into a data frame rich with information:

```{r}
# generate a data frame
mds_df <- data.frame(MDS1 = mds$points[,1],
                     MDS2 = mds$points[,2],
                     individual=with(samples, get("individual")),
                     environment=with(samples, get("environment")),
                     site=with(samples, get("site")))

# take a peek
head(mds_df)
```

Well, this is more like it. Now we can take a look this with `ggplot`:

```{r}
p <- ggplot(data = mds_df, aes(MDS1, MDS2))
p <- p + geom_point(size=1)
p
```

This is not much better than the previous plot, but this time we can easily manipulate our visual objects. Let's say we color our points in this display by `environment` to ask this very question: "from the perspective of microbes, do our guts look like our mouths?":

```{r}
p <- ggplot(data = mds_df, aes(MDS1, MDS2))
p <- p + geom_point(aes(color=environment), size=1)
p
```

This is relieving.

Let's remove all gut samples to focus solely on oral microbes:

```{r}
# take the subset of both data frames:
oral_oligotypes <- oligotypes[!grepl("_ST", oligotypes$sample), ]
oral_samples <- samples[samples$environment == "ORAL_CAVITY", ]

# set the factors straight:
oral_samples$sample <- factor(oral_samples$sample)
oral_samples$site <- factor(oral_samples$site)
```

Since we changed the shape of the data quite a bit, it is better to re-compute the ordination of our samples:

```{r}
# new mds object:
oral_mds <- metaMDS(oral_oligotypes[,-1], distance='horn')

# generating a data frame from it:
oral_mds_df <- data.frame(MDS1 = oral_mds$points[,1],
                         MDS2 = oral_mds$points[,2],
                         individual=with(oral_samples, get("individual")),
                         site=with(oral_samples, get("site")))

# taking a quick look from it because why not:
head(oral_mds_df)
```

Alright! Let's take a quick look:

```{r}
p <- ggplot(data = oral_mds_df, aes(MDS1, MDS2))
p <- p + geom_point(size=1)
p
```

What a chaos. What if we color based on individuals:

```{r}
p <- ggplot(data = oral_mds_df, aes(MDS1, MDS2))
p <- p + geom_point(aes(color=individual), size=1)
p
```

Ouch. We don't see anything, because the legend takes the entire space. Let's disable the legend and try again:

```{r}
p <- ggplot(data = oral_mds_df, aes(MDS1, MDS2))
p <- p + geom_point(aes(color=individual), size=1)
p <- p + theme(legend.position="none")
p
```

Much better. But this doesn't seem to have any structure. Why?

OK. How about we color samples based on oral sites:

```{r}
p <- ggplot(data = oral_mds_df, aes(MDS1, MDS2))
p <- p + geom_point(aes(color=site), size=1)
p <- p + theme(legend.position="none")
p
```

Aha!

What does this tell us?

(It would be great to do an anova here to show oral sites explain a much more significant amount of variance in the dataset before moving on to the next chapter)

### Making publication-ready visualizations with R

Let's say we wish to put some circles around our gorups to help visualize their distribution and dispersal.

The function below will help us do that by returning all the `x` and `y` coordinates to draw a perfect ellipse on an ordination. It is coming from the depths of the library `vegan`, and here we simply are hacking it so we can use it to put ellipses on an ordination drawn by `ggplot`, rather than `vegan`:

```{r}
veganCovEllipse <- function (cov_matrix, center){
  theta <- (0:100) * 2 * pi/100
  circle <- cbind(cos(theta), sin(theta))

  # here we have a perfect circle around the point zero, and the following line will
  # turn it into an ellipse by centering and multiplying that innocent circle with the
  # Choleski-decomposed input covariance matrix, which will represents the variation
  # among the distribution of samples that belong to a single group on the ordination
  # (this part will be much clear when you look at the for loop in the next step where
  # this function is called). if you are not familiar, the notation `%*%` is for
  # matrix multiplication. yes, you got it. this entire thing is absolute magic!
  ell <- t(center + t(circle %*% chol(cov_matrix)))

  return(as.data.frame(ell))
}
```

Using the magic up above, we will generate a new data frame, `ellipses_df`, to keep track of ellipses around our data points by going through each group in the for loop below:

```{r}
ellipses_df <- data.frame()

# mighty for loop .. it looks ugly, but is very simple:
for(g in levels(oral_mds_df$site)){
  # get a smaller data frame just for site:
  s_df <- oral_mds_df[oral_mds_df$site==g, ]

  # calculate its center and its covariance matrix:
  center <- c(mean(s_df$MDS1), mean(s_df$MDS2))
  cov_matrix <- cov.wt(cbind(s_df$MDS1, s_df$MDS2))$cov

  # get the ellipse:
  ellipse <-veganCovEllipse(cov_matrix, center)

  # add the new ellipse to the data frame
  ellipses_df <- rbind(ellipses_df, cbind(ellipse, group=g))
}

# let's name the columns in our data frame more appropriately:
names(ellipses_df) <- c('x_coord', 'y_coord', 'group')
```

OK. You must be curious about what comes out of this black magic. Let's take a look at this new data frame:

```{r}
head(ellipses_df)
```

Don't let it fool you, this data frame has many entries since it is supposed to draw elliptic objects on our ordination:

> can you predict how many points should it have by looking at the function `veganCovEllipse`?

```{r}
nrow(ellipses_df)
```

We still have the `ggplot` object in memory, let's add the data frame we just put together:

```{r}
p <- p + geom_path(data=ellipses_df,
                   aes(x=x_coord, y=y_coord, colour=group),
                   size=2,
                   linetype=1)
p
```

There is always room for improvement:

```{r}
p <- p + geom_polygon(data=ellipses_df,
                      aes(x=x_coord, y=y_coord, group=group, fill=group),
                      alpha=0.15)
p
```

It would have been great if we knew exactly what these ellipses represent. Let's add some labels at the center of each. For this, we first need to compute the group means of our samples:

```{r}
oral_mds_group_means = aggregate(oral_mds_df[,1:2], 
                                 list(group=with(oral_samples, get('site'))), 
                                 mean)
```

Basically this is a new data frame that looks like this:

```{r}
oral_mds_group_means
```

And we can extend the `ggplot` object with one more layer:

```{r}
p <- p + annotate("text",
                  x=oral_mds_group_means$MDS1,
                  y=oral_mds_group_means$MDS2,
                  label=oral_mds_group_means$group,
                  size=7, 
                  fontface = 2)
p
```

### Conclusions

Summary of what we did.